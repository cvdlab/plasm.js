var docstring = "<h3><code>BEZIER(sel)(controlpoints)</code></h3>\n\n<p>Transfinite mapping function of genric degree Bezier curve.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Function</code> <code>selector</code>: domain coordinate selector function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>v</code>: point of the <code>domain</code>.</p>\n\n<h4>out</h4>\n\n<p><code>Number</code>: the selected coordinate. </p>\n</blockquote>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controlpoints</code>: an array of points and curve mapping functions describing curve control points.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous mapping function.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain = INTERVALS(1)(32);\nvar controlpoints = [[-0,0],[1,0],[1,1],[2,1],[3,1]];\nvar curveMapping = BEZIER(S0)(controlpoints);\nvar curve = MAP(curveMapping)(domain);\nDRAW(curve);\n</code></p>\n\n<p><code>js\nvar domain = PROD1x1([INTERVALS(1)(16),INTERVALS(1)(16)]);\nvar c0 = BEZIER(S0)([[0,0,0],[10,0,0]]);\nvar c1 = BEZIER(S0)([[0,2,0],[8,3,0],[9,2,0]]);\nvar c2 = BEZIER(S0)([[0,4,1],[7,5,-1],[8,5,1],[12,4,0]]);\nvar c3 = BEZIER(S0)([[0,6,0],[9,6,3],[10,6,-1]]);\nvar out = MAP(BEZIER(S1)([c0,c1,c2,c3]))(domain);\nDRAW(out);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>BOUNDARY(d)(model)</code></h3>\n\n<p>Get the <code>d</code>-boundary of the <code>model</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>d</code>: space dimension.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: the <code>d</code>-boundary of the <code>model</code>.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar d = 1;\nvar model = TORUS_SURFACE()();\nvar boundary = BOUNDARY(d)(model);\nDRAW(boundary);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CANCEL(object)</code></h3>\n\n<p>Remove the <code>object</code> from the scene graph.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to cancel.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the cancelled object.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = TORUS_SURFACE()();\nDRAW(model);\nCANCEL(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CIRCLE(r)(divs)</code></h3>\n\n<p>Create a circle with radius <code>r</code>, approximated by <code>divs</code> segments.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>r</code>: the radius of the circle.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>divs</code>: the number of segments that approximate the circle.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: the circle with radius <code>r</code>, approximated by <code>divs</code> segments.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar r = 1.5;\nvar divs = 32;\nvar circle = CIRCLE(r)(divs);\nDRAW(circle);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>COLOR(color)(object)</code></h3>\n\n<p>Clone <code>object</code> and color cloned object with <code>color</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>color</code>: rgba color components (from <code>0</code> to <code>1</code>).</p>\n\n<ul>\n<li><code>Number</code> <code>r</code>: red component (from <code>0</code> to <code>1</code>, <code>0</code> by default).</li>\n<li><code>Number</code> <code>g</code>: green component (from <code>0</code> to <code>1</code>, <code>0</code> by default).</li>\n<li><code>Number</code> <code>b</code>: blue component (from <code>0</code> to <code>1</code>, <code>0</code> by default).</li>\n<li><code>Number</code> <code>a</code>: alpha component (from <code>0</code> to <code>1</code>, <code>1</code> by default).</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to color.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code>: the cloned colored object. </p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar color = [0.8, 0.4, 0.2, 0.7];\nvar model = TORUS_SURFACE()();\nvar coloredModel = COLOR(color)(model);\nDRAW(coloredModel);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CUBE(dim)</code></h3>\n\n<p>Create a <code>dim</code>-dimensional cube.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>dim</code>: dimension of the cube.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a cube with <code>dim</code> dimension.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar dim = 2;\nvar cube = CUBE(dim);\nDRAW(cube);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CUBIC_CARDINAL(domain)</code></h3>\n\n<p>Tranfinite Cubic cardinal splines curve generator function on <code>domain</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> <code>domain</code>: domain of the generator function.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controlpoints</code>: an array of points and curve mapping functions describing curve control points.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a spline segment.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain = INTERVALS(1)(20);\nvar controlpoints = [[-3,6],[-4,2],[-3,-1],[-1,1],[1.5,1.5],[3,4],[5,5],[7,2],[6,-2],[2,-3]];\nvar splineCardinal = SPLINE(CUBIC_CARDINAL(domain))(controlpoints);\nDRAW(splineCardinal);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CUBIC_HERMITE(selector)(controlpoints)</code></h3>\n\n<p>Transfinite mapping function of cubic Hermite curve.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Function</code> <code>selector</code>: domain coordinate selector function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>v</code>: point of the <code>domain</code>.</p>\n\n<h4>out</h4>\n\n<p><code>Number</code>: the selected coordinate. </p>\n</blockquote>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controlpoints</code>: an array of points and curve mapping functions describing curve control points.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous mapping function.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain = INTERVALS(1)(20);\nvar controlpoints = [[1,0],[1,1],[ -1, 1],[ 1,0]];\nvar curveMapping = CUBIC_HERMITE(S0)(controlpoints);\nvar curve = MAP(curveMapping)(domain);\nDRAW(curve);\n</code></p>\n\n<p><code>js\nvar domain = PROD1x1([INTERVALS(1)(14),INTERVALS(1)(14)]);\nvar c1 = CUBIC_HERMITE(S0)([[1,0,0],[0,1,0],[0,3,0],[-3,0,0]]);\nvar c2 = CUBIC_HERMITE(S0)([[0.5,0,0],[0,0.5,0],[0,1,0],[-1,0,0]]);\nvar sur3 = CUBIC_HERMITE(S1)([c1,c2,[1,1,1],[-1,-1,-1]]);\nvar out = MAP(sur3)(domain);\nDRAW(out);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CUBIC_UBSPLINE(domain)</code></h3>\n\n<p>Tranfinite cubic uniform B-splines curve generator function on <code>domain</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> <code>domain</code>: domain of the generator function.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controlpoints</code>: an array of points and curve mapping functions describing curve control points.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a spline segment.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain = INTERVALS(1)(20);\nvar controlpoints = [[-3,6],[-4,2],[-3,-1],[-1,1],[1.5,1.5],[3,4],[5,5],[7,2],[6,-2],[2,-3]];\nvar splineCubic = SPLINE(CUBIC_UBSPLINE(domain))(controlpoints);\nDRAW(splineCubic);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>CUBOID(dims)</code></h3>\n\n<p>Create a cuboidal simplicial complex with dimensions <code>[dx, dy, dz, ...]</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: sides length for each dimension of the simplicial complex.</p>\n\n<ul>\n<li><code>Number</code> <code>dx</code>: dimension along x axe</li>\n<li><code>Number</code> <code>dy</code>: dimension along y axe</li>\n<li><code>Number</code> <code>dz</code>: dimension along z axe</li>\n<li>...</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a cuboidal simplicial complex with dimensions <code>[dx, dy, dz, ...]</code>.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p>```js\nvar dx = 1;\nvar dy = 2;\nvar dz = 3;</p>\n\n<p>var cuboid1 = CUBOID([dx]);\nDRAW(cuboid1);\n<code>\n</code>js\nvar cuboid2 = CUBOID([dx, dy]);\nDRAW(cuboid2);\n<code>\n</code>js\nvar cuboid3 = CUBOID([dx, dy, dz]);\nDRAW(cuboid3);\n```</p>\n</blockquote>\n\n<hr />\n\n<h3><code>CYL_SURFACE(dims)(divs)</code></h3>\n\n<p>Create a cylindrical surface.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: dimensions <code>[r, h]</code>.</p>\n\n<ul>\n<li><code>Number</code> <code>r</code>: the radius (<code>1</code> by default).</li>\n<li><code>Number</code> <code>h</code>: the height (<code>1</code> by default).</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>divs</code>: divisions <code>[slices, stacks]</code>.</p>\n\n<ul>\n<li><code>Number</code> <code>slices</code>: slices (<code>16</code> by default).</li>\n<li><code>Number</code> <code>stacks</code>: stacks (<code>2</code> by default).</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a cylindrical surface with radius <code>r</code> and height <code>h</code>, divided in <code>slices</code> and <code>stacks</code>. </p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = CYLSURFACE()();\nDRAW(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>DISK(r)(divs)</code></h3>\n\n<p>Create a disk surface with radius <code>r</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>r</code>: the radius (<code>1</code> by default).</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>divs</code>: divisions <code>[slices, stacks]</code>.</p>\n\n<ul>\n<li><code>Number</code> <code>slices</code>: slices (<code>16</code> by default).</li>\n<li><code>Number</code> <code>stacks</code>: stacks (<code>2</code> by default).</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a disk with radius <code>r</code>, divided in <code>slices</code> and <code>stacks</code>. </p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = DISK()();\nDRAW(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>DOMAIN(dims)(divs)</code></h3>\n\n<p>Create a domain.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: dimensions <code>[dx, dy, dz, ...]</code>.</p>\n\n<ul>\n<li><code>Array</code> <code>dx</code>: intervals <code>[start_x, end_x]</code>\n<ul><li><code>Number</code> <code>start_x</code>: x min</li>\n<li><code>Number</code> <code>end_x</code>: x max</li></ul></li>\n<li><code>Array</code> <code>dy</code>: intervals <code>[start_y, end_y]</code>\n<ul><li><code>Number</code> <code>start_y</code>: y min</li>\n<li><code>Number</code> <code>end_y</code>: y max</li></ul></li>\n<li><code>Array</code> <code>dz</code>: intervals <code>[start_z, end_z]</code>\n<ul><li><code>Number</code> <code>start_z</code>: z min</li>\n<li><code>Number</code> <code>end_z</code>: z max</li></ul></li>\n<li>...</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>divs</code>: divisions <code>[nx, ny, nz, ...]</code>.</p>\n\n<ul>\n<li><code>Number</code> <code>nx</code>: division along x axes.</li>\n<li><code>Number</code> <code>ny</code>: division along y axes.</li>\n<li><code>Number</code> <code>nz</code>: division along z axes.</li>\n<li>...</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a domain. </p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain1 = DOMAIN([[0,PI])([32]);\nDRAW(domain1);\n</code>\n<code>js\nvar domain2 = DOMAIN([[0,PI], [0,1]])([32, 2]);\nDRAW(domain2);\n</code>\n<code>js\nvar domain3 = DOMAIN([[0,PI], [0,1], [0,0.5]])([32, 2, 5]);\nDRAW(domain3);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>DRAW(object)</code></h3>\n\n<p>Draw an object of 3 or less dimensions.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to draw.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object drawn.</p>\n</blockquote>\n\n<hr />\n\n<h4><code>EXPLODE(values)(model)</code></h4>\n\n<p>Explode a <code>model</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>values</code>: <code>[dx, dy, dz, ...]</code></p>\n\n<ul>\n<li><code>Number</code> <code>dx</code>: explosion factor along x axe</li>\n<li><code>Number</code> <code>dy</code>: explosion factor along y axe</li>\n<li><code>Number</code> <code>dx</code>: explosion factor along z axe</li>\n<li>...</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonimous function. </p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> <code>model</code>: the model to explode.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: the model exploded.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = TORUS_SURFACE()();\nvar exploded = EXLODE([2,2,2])(model);\nDRAW(exploded);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h4><code>EXTRUDE(hlist)(object)</code></h4>\n\n<p>Extrude an <code>object</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>hlist</code></p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonimous function. </p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>objetc</code>: the object to extrude.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>objetc</code>: the extruded object.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = SIMPLEX(1);\nvar extruded = EXTRUDE([1])(model);\nDRAW(extruded);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h4><code>HIDE(object)</code></h4>\n\n<p>Hide the <code>object</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>objetc</code>: the object to hide.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code>: the hidden model.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = TORUS_SURFACE()();\nDRAW(model);\nHIDE(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>INTERVALS(length)(n)</code></h3>\n\n<p>Create a segment from <code>0</code> to <code>length</code> divided in <code>n</code> parts.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>length</code>: the length of the interval.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonimous function. </p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>n</code>: the number of divisions.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a segment from <code>0</code> to <code>length</code> divided in <code>n</code> parts.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar intervals = INTERVALS(10)(5);\nDRAW(intervals);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>MAP(mapping)(domain)</code></h3>\n\n<p>Map a <code>domain</code> by a <code>mapping</code> function.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Function|Array</code> <code>mapping</code>: the mapping function (or array of function)</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>v</code>: point of the <code>domain</code>.</p>\n\n<h4>out</h4>\n\n<p><code>Array</code>: the mapped point. </p>\n</blockquote>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> <code>domain</code>: the domain to map.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: the mapped domain.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar mapping = function (v) { return [v[0] + 1, v[1], v[2]];\nvar model = TORUS_SURFACE()();\nvar mapped = MAP(mapping)(model);\nDRAW(mapped);\n</code></p>\n\n<p><code>js\nvar domain = DOMAIN([[0,1]],[0,2*PI]);\nvar mapping = function (v) { return [SIN(v[0]), COS(v[1])]; });\nvar model = MAP(mapping)(domain);\nDRAW(model);\n</code></p>\n\n<p><code>js\nvar domain = DOMAIN([[0,1]],[0,2*PI]);\nvar mapping = [\n  function (v) { return SIN(v[0]); }, \n  function (v) { return COS(v[1]); }\n]);\nvar model = MAP(mapping)(domain)\nDRAW(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>NUBSLINE(degree)(knots)(controls)</code></h3>\n\n<p>Non-uniform B-Spline.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>degree</code>: spline degree.\n<code>Number</code> <code>[totpoints=80]</code>: total number of spline's points.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>knots</code>: Array of integer describing spline's knots.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controls</code>: Array of integer describing spline's control points.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: non uniform spline.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar controls = [[0,0],[-1,2],[1,4],[2,3],[1,1],[1,2],[2.5,1],[2.5,3],[4,4],[5,0]];\nvar knots = [0,0,0,0,1,2,3,4,5,6,7,7,7,7];\nvar nubspline = NUBSPLINE(3)(knots)(controls);\nDRAW(nubspline);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>NUBS(sel)(degree)(knots)(controls)</code></h3>\n\n<p>Transfinite Non-uniform B-Spline.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Function</code> <code>sel</code>: selctor function.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>degree</code>: spline degree.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>knots</code>: Array of integer describing spline's knots.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controls</code>: Array of integer describing spline's control points.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: non uniform spline.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain = INTERVALS(1)(20);\nvar controls = [[0,0],[-1,2],[1,4],[2,3],[1,1],[1,2],[2.5,1],[2.5,3],[4,4],[5,0]];\nvar nubs = NUBS(S0)(3)([0,0,0,0,1,2,3,4,5,6,7,7,7,7])(controls);\nvar model = MAP(nubs)(domain);\nDRAW(model);\n</code></p>\n\n<p><code>js\nvar domain = DOMAIN([[0,1],[0,1]])([30,30]);\nvar b0 = BEZIER(S0)([[0,0,0],[5,-10,0],[10,0,0]]);\nvar b1 = BEZIER(S0)([[0,2,0],[8,3,0],[9,2,0]]);\nvar b2 = BEZIER(S0)([[0,4,1],[7,5,-1],[8,5,1],[12,4,0]]);\nvar b3 = BEZIER(S0)([[0,6,0],[9,6,3],[10,6,-1]]);\nvar controls = [b0,b1,b2,b3];\nvar nubs = NUBS(S1)(3)([0,0,0,0,7,7,7,7])(controls);\nvar model = MAP(nubs)(domain);\nDRAW(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>NURBSLINE(degree)(knots)(controls)</code></h3>\n\n<p>Non-uniform Rational B-Spline.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>degree</code>: spline degree.\n<code>Number</code> <code>[totpoints=80]</code>: total number of spline's points.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>knots</code>: Array of integer describing spline's knots.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controls</code>: Array of integer describing spline's control points.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: non uniform rational spline.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar _p = Math.sqrt(2)/2.0;\nvar controls = [[-1,0,1], [-_p,_p,_p], [0,1,1], [_p,_p,_p],[1,0,1], [_p,-_p,_p], [0,-1,1], [-_p,-_p,_p], [-1,0,1]];\nvar knots = [0,0,0,1,1,2,2,3,3,4,4,4];\nvar nurbs = NURBSPLINE(2)(knots)(controls);\nDRAW(nurbs);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>POLYLINE(points)</code></h3>\n\n<p>Create a polyline made by <code>points</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>points</code>: an array of points (<code>[p0, p1, ...]</code>):</p>\n\n<ul>\n<li><code>Array</code> <code>points[i]</code> <code>point</code>: <code>i</code>-th point\n<ul><li><code>Number</code> <code>point[k]</code>: <code>k</code>-th coord of <code>point</code></li></ul></li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a polyline made by <code>points</code>.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar points = [[0,0], [1,1], [2,0]];\nvar polyline = POLYLINE(points);\nDRAW(polyline);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>POLYPOINT(points)</code></h3>\n\n<p>Create a 0D complex.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>points</code>: an array of points (<code>[p0, p1, ...]</code>):</p>\n\n<ul>\n<li><code>Array</code> <code>points[i]</code> <code>point</code>: <code>i</code>-th point\n<ul><li><code>Number</code> <code>point[k]</code>: <code>k</code>-th coord of <code>point</code></li></ul></li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a polypoint made by <code>points</code>.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar points = [[0,0], [1,1], [2,0]];\nvar polypoint = POLYPOINT(points);\nDRAW(polypoint);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>PROD1x1(array)</code></h3>\n\n<p>Return cartesian product of the two models in <code>array</code>. <br />\nEach model must have Rn equals to 1.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>array</code>: an array of the two operand models (<code>[model1, model2]</code>):</p>\n\n<ul>\n<li><code>Array</code> <code>array[0]</code> <code>model1</code>: the first operand model</li>\n<li><code>Array</code> <code>array[1]</code> <code>model2</code>: the second operand model</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: result of the product of the two models</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar a = POLYLINE([[1],[3],[4]]);\nvar b = POLYLINE([[2.2],[3.5],[7.8],[9.0]]);\nvar axb = PROD1x1([a,b]);\nDRAW(STRUCT([axb, SKELETON(1)(axb)]));\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>PROD1x2(array)</code></h3>\n\n<p>Return cartesian product of the two models in <code>array</code>. <br />\nThe first model must have Rn equals to 1. <br />\nThe second model must have Rn equals to 2.  </p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>array</code>: an array of the two operand models (<code>[model1, model2]</code>):</p>\n\n<ul>\n<li><code>Array</code> <code>array[0]</code> <code>model1</code>: the first operand model</li>\n<li><code>Array</code> <code>array[1]</code> <code>model2</code>: the second operand model</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: result of the product of the two models</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar a = POLYLINE([[1],[3],[4]]);\nvar b = POLYLINE([[0,2],[1,1],[2,1],[3,0]]);\nvar axb = PROD1x2([a,b]);\nDRAW(STRUCT([axb, SKELETON(1)(axb)]));\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>PROD2x1(array)</code></h3>\n\n<p>Return cartesian product of the two models in <code>array</code>. <br />\nThe first model must have Rn equals to 2. <br />\nThe second model must have Rn equals to 1.  </p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>array</code>: an array of the two operand models (<code>[model1, model2]</code>):</p>\n\n<ul>\n<li><code>Array</code> <code>array[0]</code> <code>model1</code>: the first operand model</li>\n<li><code>Array</code> <code>array[1]</code> <code>model2</code>: the second operand model</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: result of the product of the two models</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar a = POLYLINE([[1],[3],[4]]);\nvar b = POLYLINE([[0,2],[1,1],[2,1],[3,0]]);\nvar bxa = PROD2x1([b,a]);\nDRAW(STRUCT([bxa, SKELETON(1)(bxa)]));\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>ROTATE(dims)(angle)(object)</code> / <code>R(dims)(angle)(object)</code></h3>\n\n<p>Rotate <code>object</code> by <code>angle</code> on the rotational plane described by <code>dims</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: an array of <code>Number</code> specifying dimensions forming the rotational plane on which rotate the object.</p>\n\n<ul>\n<li><code>Array</code> <code>dims[0]</code> <code>dims1</code>: the first dimension of the rotational plane.</li>\n<li><code>Array</code> <code>dims[1]</code> <code>dims2</code>: the second dimension of the rotational plane.</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Funciton</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>angle</code>: rotational angle (in radiant, from <code>0</code> to <code>2Ï€</code>).</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to rotate.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code>: the rotated object.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = TORUS_SURFACE()();\nvar rotated = ROTATE([0,1])(PI/3)(model);\nDRAW(rotated);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SCALE(axis)(values)(object)</code> / <code>S(axis)(values)(object)</code></h3>\n\n<p>Scale <code>model</code> by <code>values</code> along <code>axis</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>axis</code>: axis to scale along.</p>\n\n<h4>out</h4>\n\n<p><code>Funciton</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>values</code>: scaling factors.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to scale.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code>: the scaled object.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = TORUS_SURFACE()();\nvar scaled = SCALE([1,2])([2,0.5])(model);\nDRAW(scaled);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SHOW(object)</code></h3>\n\n<p>Show a hidden <code>object</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to show.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code>: the shown model.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = TORUS_SURFACE()();\nDRAW(model);\nHIDE(model);\nSHOW(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SIMPLEX(dim)</code></h3>\n\n<p>Create a <code>dim</code>-dimensional simplex with sides length equal to 1.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>dim</code>: simplex dimension.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a simplex of dim <code>dim</code>.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar simplex = SIMPLEX(3);\nDRAW(simplex);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SIMPLEX_GRID(quotes)</code></h3>\n\n<p>Create a grid simplicial complex.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>quotes</code>: an array of array of quotes for each dimension of the grid, starting from dimension 0. <br />\nQuotes may be both positive and negative: </p>\n\n<ul>\n<li>positive ones are actually generated, </li>\n<li>negative ones are considered as a positive spacing.</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a grid simplicial complex.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar model = SIMPLEX_GRID([1,-1,1]);\nDRAW(model);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SIMPLICIAL_COMPLEX(points)(cells)</code></h3>\n\n<p>Create a simplicial complex.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>points</code>: an array of points, represented as arrays of coordinates.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>cells</code>: complex's highest order cells represented as arrays of indices of <code>points</code>.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a simplicial complex.</p>\n</blockquote>\n\n<p><code>js\nvar points = [[0,0],[1,0],[0,1],[1,1],[0.5,1.5]];\nvar cells = [[0,1,2],[1,3,2],[2,3,4]];\nvar simplicialComplex = SIMPLICIAL_COMPLEX(points)(cells);\nDRAW(simplicialComplex);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SKELETON(dim)(model)</code></h3>\n\n<p>Extract the <code>dim</code>-skeleton of the <code>model</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Number</code> <code>dim</code>: dimension of the skeleton.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> <code>model</code>: model to which extract skeleton. </p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: <code>dim</code>-skeleton of the <code>model</code>.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar cuboid = CUBOID([1,2,3]);\nvar skeleton1 = SKELETON(1)(cuboid);\nDRAW(skeleton1);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>SPLINE(curve)(controlpoints)</code></h3>\n\n<p>Create spline curve.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Function</code> <code>curve</code>: spline curve generator function, such as the result of application of <code>CUBIC_UBSPLINE</code> or <code>CUBIC_CARDINAL</code> to a domain.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: an anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>controlpoints</code>: an array of points and curve mapping functions describing curve control points.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Struct</code>: the spline.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar domain = INTERVALS(1)(20);\nvar controlpoints = [[-3,6],[-4,2],[-3,-1],[-1,1],[1.5,1.5],[3,4],[5,5],[7,2],[6,-2],[2,-3]];\nvar splineCardinal = COLOR([1,0,0])(SPLINE(CUBIC_CARDINAL(domain))(controlpoints));\nvar splineCubic = COLOR([0,1,0])(SPLINE(CUBIC_UBSPLINE(domain))(controlpoints));\nvar points = SIMPLICIAL_COMPLEX(controlpoints)([[0],[1],[2],[3],[4],[5],[6],[7],[8],[9]]);\nvar out = STRUCT([splineCardinal,splineCubic,points]);\nDRAW(out);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>STRUCT(items)</code></h3>\n\n<p>Structure together <code>plasm.Model</code> and <code>plasm.Struct</code>. <br />\nIf a transformation is encountered in <code>items</code>, <br />\nit is applied to all of the following items.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>items</code>: an array of <code>plasm.Model</code> or <code>plasm.Struct</code> or <code>Function</code></p>\n\n<h4>out</h4>\n\n<p>instance of <code>plasm.Struct</code>: a struct.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar cube1 = CUBE(3);\nvar cube2 = T([0])([1.3])(cube1);\nvar struct1 = STRUCT([cube1, cube2]);\nvar t = T([1])([1.3]);\nvar struct = STRUCT([struct1, t, struct1, t, cube1]);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>TORUS_SOLID(dims)(divs)</code></h3>\n\n<p>Create a torus solid.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: size of the radii <code>[rMin, rMax]</code></p>\n\n<ul>\n<li><code>Number</code> <code>rMin</code>: internal radius (<code>0.1</code> by default)</li>\n<li><code>Number</code> <code>rMax</code>: external radius (<code>0.9</code> by default)</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Function</code>: anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>divs</code>: a triple of approssimation values <code>[m, n, o]</code></p>\n\n<ul>\n<li><code>Number</code> <code>m</code>: (<code>12</code> by default)</li>\n<li><code>Number</code> <code>n</code>: (<code>8</code> by default)</li>\n<li><code>Number</code> <code>o</code>: (<code>8</code> by default)</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a solid torus.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\ntorusSolid = TORUS_SOLID([0.1, 0.9])([12,8,8]);\nDRAW(torusSolid);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>TORUS_SURFACE(dims)(divs)</code></h3>\n\n<p>Create a toroidal surface.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: size of the radii <code>[rMin, rMax]</code></p>\n\n<ul>\n<li><code>Number</code> <code>rMin</code>: internal radius (<code>0.1</code> by default)</li>\n<li><code>Number</code> <code>rMax</code>: external radius (<code>0.9</code> by default)</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>Function</code>: anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>divs</code>: a couple of approssimation values <code>[m, n, o]</code></p>\n\n<ul>\n<li><code>Number</code> <code>m</code>: slices (<code>12</code> by default)</li>\n<li><code>Number</code> <code>n</code>: stacks (<code>8</code> by default)</li>\n</ul>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code>: a toroidal surface.</p>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar torusSurface = TORUS_SURFACE([0.1, 0.9])([12,8]);\nDRAW(torusSurface);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>TRANSLATE(dims)(values)(object)</code> / <code>T(dims)(values)(object)</code></h3>\n\n<p>Clone <code>model</code> and translate cloned model by <code>values</code> on dimensions <code>dims</code>.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>dims</code>: an array of <code>Number</code> specifying which dimensions translate (first dim has index 0).</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>values</code>: an array of <code>Number</code> specifying translation quantity for every dimension in <code>dims</code>.</p>\n\n<h4>out</h4>\n\n<p><code>Function</code>: anonymous function.</p>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code> <code>object</code>: the object to translate.</p>\n\n<h4>out</h4>\n\n<p><code>plasm.Model</code> or <code>plasm.Struct</code>: the translated object.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar cube = CUBE(3);\nvar translatedCube = T([1,2])([1,3])(cube);\nDRAW(translatedCube);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>TRIANGLE_FAN(points)</code></h3>\n\n<p>Create a tiangle fan: first point is the center of the fan, <br />\ncenter point is used with next two points to form a triangle. <br />\nEvery successive point is used with center point and the previuos point to form a triangle.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>points</code>: an array of points, represented as arrays of coordinates.</p>\n\n<h4>out</h4>\n\n<p>instance of <code>plasm.Model</code>: a triangle fan.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar points = [[0,0,0],[0,1,0],[1,0,0],[0,-1,0],[-1,0,0]];\nvar triStrip = TRIANGLE_FAN(points);\nDRAW(triStrip);\n</code></p>\n</blockquote>\n\n<hr />\n\n<h3><code>TRIANGLE_STRIP(points)</code></h3>\n\n<p>Create a tiangle strip: first three points made a triangle, <br />\nevery other point is used with next two points to form a triangle.</p>\n\n<h4>I/O</h4>\n\n<blockquote>\n  <h4>in</h4>\n\n<p><code>Array</code> <code>points</code>: an array of points, represented as arrays of coordinates.</p>\n\n<h4>out</h4>\n\n<p>instance of <code>plasm.Model</code>: a triangle strip.</p>\n</blockquote>\n\n<h4>Example</h4>\n\n<blockquote>\n  <p><code>js\nvar points = [[0,0,0],[0,1,0],[1,0,0],[1,1,0],[2,0,0]];\nvar triStrip = TRIANGLE_STRIP(points);\nDRAW(triStrip);\n</code></p>\n</blockquote>";